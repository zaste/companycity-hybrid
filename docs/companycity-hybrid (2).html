                scene.fog.color.setHex(0x050510);<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CompanyCity - Adaptive Infrastructure Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #050510;
            color: #fff;
            font-family: -apple-system, 'SF Pro Display', sans-serif;
            overflow: hidden;
            cursor: grab;
        }
        
        body.grabbing {
            cursor: grabbing;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* Adaptive UI - changes based on zoom level */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Navigation breadcrumb */
        #nav {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 12px;
            padding: 12px 20px;
            font-size: 13px;
            pointer-events: auto;
            transition: all 0.3s ease;
        }
        
        #nav.minimal {
            background: transparent;
            border: none;
            backdrop-filter: none;
            color: #666;
            font-size: 11px;
        }
        
        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .breadcrumb-item {
            color: #8b8b8b;
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .breadcrumb-item:hover {
            color: #8b5cf6;
        }
        
        .breadcrumb-current {
            color: #fff;
            font-weight: 500;
        }
        
        /* District labels (city view) */
        .district-label {
            position: absolute;
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-shadow: 
                0 0 20px rgba(0,0,0,0.9),
                0 0 40px rgba(139, 92, 246, 0.3);
            transform: translate(-50%, -50%);
        }
        
        .district-label.visible {
            opacity: 1;
        }
        
        /* Node labels (network view) */
        .node-label {
            position: absolute;
            color: #fff;
            font-size: 11px;
            font-weight: 400;
            padding: 4px 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
            transform: translate(-50%, -150%);
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        
        .node-label.visible {
            opacity: 1;
        }
        
        /* HUD - adaptive based on view */
        #hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 12px;
            padding: 16px;
            min-width: 200px;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: auto;
        }
        
        #hud.visible {
            opacity: 1;
        }
        
        .hud-title {
            font-size: 12px;
            color: #8b8b8b;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 13px;
        }
        
        .metric-label {
            color: #8b8b8b;
        }
        
        .metric-value {
            color: #8b5cf6;
            font-weight: 600;
        }
        
        /* Inspector panel */
        #inspector {
            position: absolute;
            right: 20px;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            padding: 20px;
            width: 320px;
            max-height: 400px;
            overflow-y: auto;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: auto;
        }
        
        #inspector.visible {
            opacity: 1;
        }
        
        .inspector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .inspector-title {
            font-size: 16px;
            font-weight: 600;
            color: #8b5cf6;
        }
        
        .inspector-close {
            cursor: pointer;
            color: #8b8b8b;
            font-size: 18px;
            transition: color 0.2s;
        }
        
        .inspector-close:hover {
            color: #fff;
        }
        
        /* View mode indicator */
        #view-mode {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            color: #666;
            font-family: 'SF Mono', monospace;
            transition: opacity 0.3s ease;
        }
        
        /* Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: auto;
        }
        
        #controls.visible {
            opacity: 1;
        }
        
        .control-btn {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #8b8b8b;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            color: #8b5cf6;
            border-color: #8b5cf6;
        }
        
        .control-btn.active {
            color: #fff;
            background: #8b5cf6;
            border-color: #8b5cf6;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            color: #8b5cf6;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="container">
        <div id="loading">INITIALIZING INFRASTRUCTURE...</div>
        
        <div id="ui-layer">
            <!-- Navigation -->
            <nav id="nav">
                <div class="breadcrumb">
                    <span class="breadcrumb-item" onclick="window.setViewLevel('city')">CompanyCity</span>
                    <span id="breadcrumb-sep" style="display: none;">›</span>
                    <span id="breadcrumb-district" class="breadcrumb-current" style="display: none;"></span>
                </div>
            </nav>
            
            <!-- HUD -->
            <div id="hud">
                <div class="hud-title" id="hud-title">System Overview</div>
                <div id="hud-content"></div>
            </div>
            
            <!-- Inspector -->
            <div id="inspector">
                <div class="inspector-header">
                    <div class="inspector-title" id="inspector-title">Details</div>
                    <div class="inspector-close" onclick="window.closeInspector()">×</div>
                </div>
                <div id="inspector-content"></div>
            </div>
            
            <!-- View Mode -->
            <div id="view-mode">CITY VIEW • SCROLL TO ZOOM</div>
            
            <!-- Controls -->
            <div id="controls">
                <button class="control-btn active" onclick="toggleFlow(event)">Data Flow</button>
                <button class="control-btn" onclick="toggleHeatmap(event)">Heat Map</button>
                <button class="control-btn" onclick="resetView()">Reset View</button>
            </div>
        </div>
    </div>
    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.Fog(0x050510, 100, 400);
        
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: false 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        document.getElementById('container').appendChild(renderer.domElement);
        
        // State management
        const state = {
            viewMode: 'city', // city, transition, network
            zoomLevel: 1,
            targetZoom: 1,
            selectedDistrict: null,
            selectedNode: null,
            showFlow: true,
            showHeatmap: false,
            mouse: { x: 0, y: 0, down: false },
            camera: {
                angle: 0, // Direct front view to appreciate hex alignment
                elevation: Math.PI * 0.35,
                distance: 140,
                targetDistance: 140
            }
        };
        
        // City structure - Aligned with hexagonal grid
        const cityData = {
            districts: []
        };
        
        // Calculate positions based on hexagonal grid
        function calculateHexagonalLayout() {
            const hexSize = 25; // Match the grid hex size
            const hexRadius = hexSize * 3; // Distance between district centers (3 hexes)
            
            // Company City - always at center (0, 0)
            cityData.districts.push({
                id: 'company-city',
                name: 'Company City',
                position: { x: 0, z: 0 },
                color: 0x8b5cf6,
                scale: 1.2,
                nodes: [
                    { id: 'event-bus', name: 'Event Bus', relPos: { x: 0, z: 0 } },
                    { id: 'cache-layer', name: 'Cache Layer', relPos: { x: -10, z: -10 } },
                    { id: 'queue-manager', name: 'Queue Manager', relPos: { x: 10, z: -10 } },
                    { id: 'monitor', name: 'System Monitor', relPos: { x: 0, z: 10 } }
                ]
            });
            
            // First ring - 6 districts in perfect hexagonal positions
            const firstRingDistricts = [
                {
                    id: 'governance-district',
                    name: 'Governance District',
                    color: 0x00ff88,
                    angle: 0, // Right
                    nodes: [
                        { id: 'lead-capture', name: 'Lead Capture', relPos: { x: -10, z: -10 } },
                        { id: 'validation', name: 'Validation Engine', relPos: { x: 10, z: -10 } },
                        { id: 'scoring', name: 'Scoring System', relPos: { x: 0, z: 10 } },
                        { id: 'routing', name: 'Smart Router', relPos: { x: -10, z: 10 } }
                    ]
                },
                {
                    id: 'tech-district',
                    name: 'Tech District',
                    color: 0x00aaff,
                    angle: Math.PI / 3, // 60 degrees
                    nodes: [
                        { id: 'etl-pipeline', name: 'ETL Pipeline', relPos: { x: 0, z: -10 } },
                        { id: 'transform-1', name: 'Transform Alpha', relPos: { x: -10, z: 10 } },
                        { id: 'transform-2', name: 'Transform Beta', relPos: { x: 10, z: 10 } },
                        { id: 'data-lake', name: 'Data Lake', relPos: { x: 0, z: 0 } }
                    ]
                },
                {
                    id: 'people-district',
                    name: 'People District',
                    color: 0xff00aa,
                    angle: 2 * Math.PI / 3, // 120 degrees
                    nodes: [
                        { id: 'orchestrator', name: 'AI Orchestrator', relPos: { x: 0, z: 0 } },
                        { id: 'ml-model-1', name: 'Prediction Model', relPos: { x: -15, z: -10 } },
                        { id: 'ml-model-2', name: 'Classification Model', relPos: { x: 15, z: -10 } },
                        { id: 'decision-engine', name: 'Decision Engine', relPos: { x: 0, z: 15 } }
                    ]
                },
                {
                    id: 'market-district',
                    name: 'Market District',
                    color: 0xff6b00,
                    angle: Math.PI, // 180 degrees (left)
                    nodes: [
                        { id: 'api-gateway', name: 'API Gateway', relPos: { x: 0, z: -10 } },
                        { id: 'webhook-handler', name: 'Webhook Handler', relPos: { x: -10, z: 10 } },
                        { id: 'event-publisher', name: 'Event Publisher', relPos: { x: 10, z: 10 } }
                    ]
                },
                {
                    id: 'delivery-district',
                    name: 'Delivery District',
                    color: 0xffff00,
                    angle: 4 * Math.PI / 3, // 240 degrees
                    nodes: [
                        { id: 'metrics-collector', name: 'Metrics Collector', relPos: { x: 0, z: -10 } },
                        { id: 'aggregator', name: 'Data Aggregator', relPos: { x: -10, z: 0 } },
                        { id: 'visualizer', name: 'Visualizer', relPos: { x: 10, z: 0 } },
                        { id: 'alerting', name: 'Alert Engine', relPos: { x: 0, z: 10 } }
                    ]
                },
                {
                    id: 'finance-district',
                    name: 'Finance District',
                    color: 0xff0066,
                    angle: 5 * Math.PI / 3, // 300 degrees
                    nodes: [
                        { id: 'auth-service', name: 'Auth Service', relPos: { x: 0, z: -10 } },
                        { id: 'encryption', name: 'Encryption Layer', relPos: { x: -10, z: 10 } },
                        { id: 'audit-log', name: 'Audit Logger', relPos: { x: 10, z: 10 } },
                        { id: 'threat-detect', name: 'Threat Detection', relPos: { x: 0, z: 0 } }
                    ]
                }
            ];
            
            // Calculate exact positions aligned with hex grid
            firstRingDistricts.forEach((district, index) => {
                // Use exact hexagonal coordinates
                const x = Math.cos(district.angle) * hexRadius;
                const z = Math.sin(district.angle) * hexRadius;
                
                district.position = { x: x, z: z };
                district.scale = 1.0;
                cityData.districts.push(district);
            });
        }
        
        // Call this before creating city
        calculateHexagonalLayout();
        
        // Visual elements
        const cityGroup = new THREE.Group();
        const districtsGroup = new THREE.Group();
        const nodesGroup = new THREE.Group();
        const connectionsGroup = new THREE.Group();
        const particles = [];
        
        // Materials
        const materials = {
            districtBase: new THREE.MeshPhongMaterial({
                color: 0x1a1a1a,
                emissive: 0x8b5cf6,
                emissiveIntensity: 0.05,
                transparent: true,
                opacity: 0.8
            }),
            districtEdge: new THREE.LineBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.3
            }),
            building: new THREE.MeshPhongMaterial({
                color: 0x2a2a2a,
                emissive: 0x8b5cf6,
                emissiveIntensity: 0.1
            }),
            node: new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0.8
            }),
            connection: new THREE.LineBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.2
            })
        };
        
        // Create city infrastructure
        function createCity() {
            // Base platform with gradient
            const platformGeometry = new THREE.PlaneGeometry(400, 400, 40, 40);
            
            // Add subtle height variation to vertices
            const positionAttribute = platformGeometry.attributes.position;
            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const z = positionAttribute.getZ(i);
                const distance = Math.sqrt(x * x + z * z);
                const height = Math.sin(distance * 0.02) * 0.5;
                positionAttribute.setY(i, height);
            }
            platformGeometry.computeVertexNormals();
            
            const platformMaterial = new THREE.MeshPhongMaterial({
                color: 0x0a0a0a,
                emissive: 0x1a1a2e,
                emissiveIntensity: 0.1,
                transparent: true,
                opacity: 0.8,
                flatShading: true
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.rotation.x = -Math.PI / 2;
            platform.position.y = -2;
            platform.receiveShadow = true;
            cityGroup.add(platform);
            
            // Hexagonal grid pattern - aligned with districts
            const gridGroup = new THREE.Group();
            const hexSize = 25; // Size of each hex in the grid
            const gridRadius = 200; // Larger grid to accommodate districts
            
            // Create hexagonal grid using axial coordinates
            for (let q = -8; q <= 8; q++) {
                for (let r = -8; r <= 8; r++) {
                    // Convert axial to pixel coordinates
                    const x = hexSize * 3/2 * q;
                    const z = hexSize * Math.sqrt(3) * (r + q/2);
                    
                    if (Math.sqrt(x*x + z*z) < gridRadius) {
                        // Check if this position should be highlighted (district location)
                        const isDistrictPosition = isNearDistrict(x, z);
                        
                        const hexGeometry = new THREE.RingGeometry(
                            hexSize * 0.8, 
                            hexSize * 0.85, 
                            6
                        );
                        const hexMaterial = new THREE.MeshBasicMaterial({
                            color: isDistrictPosition ? 0x2a2a3e : 0x1a1a2e,
                            transparent: true,
                            opacity: isDistrictPosition ? 0.25 : 0.1,
                            side: THREE.DoubleSide
                        });
                        const hexMesh = new THREE.Mesh(hexGeometry, hexMaterial);
                        hexMesh.rotation.x = -Math.PI / 2;
                        hexMesh.rotation.z = Math.PI / 6;
                        hexMesh.position.set(x, 0.1, z);
                        gridGroup.add(hexMesh);
                    }
                }
            }
            cityGroup.add(gridGroup);
            
            // Create districts
            cityData.districts.forEach(districtData => {
                const district = createDistrict(districtData);
                districtsGroup.add(district);
                
                // Create district label
                const label = document.createElement('div');
                label.className = 'district-label';
                label.textContent = districtData.name.toUpperCase();
                label.dataset.districtId = districtData.id;
                document.getElementById('ui-layer').appendChild(label);
            });
            
            // Add central glow effect - larger to match new scale
            const centralGlowGeometry = new THREE.CircleGeometry(50, 32);
            const centralGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.08
            });
            const centralGlow = new THREE.Mesh(centralGlowGeometry, centralGlowMaterial);
            centralGlow.rotation.x = -Math.PI / 2;
            centralGlow.position.y = 0.2;
            cityGroup.add(centralGlow);
            
            // Add pulsing ring around Company City - adjusted size
            const pulseRingGeometry = new THREE.RingGeometry(38, 42, 64);
            const pulseRingMaterial = new THREE.MeshBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide
            });
            const pulseRing = new THREE.Mesh(pulseRingGeometry, pulseRingMaterial);
            pulseRing.rotation.x = -Math.PI / 2;
            pulseRing.position.y = 0.5;
            pulseRing.userData.isPulseRing = true;
            cityGroup.add(pulseRing);
            
            cityGroup.add(districtsGroup);
            cityGroup.add(nodesGroup);
            cityGroup.add(connectionsGroup);
            scene.add(cityGroup);
        }
        
        // Helper function to check if a grid position is near a district
        function isNearDistrict(x, z) {
            const threshold = 35; // Distance to consider "near" - matches district size
            return cityData.districts.some(district => {
                const dx = x - district.position.x;
                const dz = z - district.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                // More precise detection for center and immediate neighbors
                return distance < threshold;
            });
        }
        
        function createDistrict(districtData) {
            const districtGroup = new THREE.Group();
            districtGroup.position.set(districtData.position.x, 0, districtData.position.z);
            districtGroup.userData = districtData;
            
            // Scale factor for district size - aligned with grid
            const scale = districtData.scale || 1.0;
            const hexSize = 35 * scale; // Smaller to fit grid cells
            
            // Perfect hexagonal platform - aligned with grid rotation
            const hexShape = new THREE.Shape();
            const angleStep = Math.PI * 2 / 6;
            const rotationOffset = Math.PI / 6; // 30 degrees to align with grid
            
            for (let i = 0; i < 6; i++) {
                const angle = angleStep * i + rotationOffset;
                const x = Math.cos(angle) * hexSize;
                const y = Math.sin(angle) * hexSize;
                
                if (i === 0) {
                    hexShape.moveTo(x, y);
                } else {
                    hexShape.lineTo(x, y);
                }
            }
            hexShape.closePath();
            
            // Extrude for 3D effect
            const extrudeSettings = {
                depth: 3,
                bevelEnabled: true,
                bevelThickness: 0.5,
                bevelSize: 0.5,
                bevelSegments: 3
            };
            
            const hexGeometry = new THREE.ExtrudeGeometry(hexShape, extrudeSettings);
            hexGeometry.rotateX(-Math.PI / 2);
            
            const districtMaterial = materials.districtBase.clone();
            districtMaterial.emissive = new THREE.Color(districtData.color);
            districtMaterial.emissiveIntensity = districtData.id === 'central-core' ? 0.1 : 0.05;
            
            const platform = new THREE.Mesh(hexGeometry, districtMaterial);
            platform.position.y = 1;
            platform.castShadow = true;
            platform.receiveShadow = true;
            districtGroup.add(platform);
            
            // Glowing edge
            const edgeGeometry = new THREE.EdgesGeometry(hexGeometry);
            const edgeMaterial = materials.districtEdge.clone();
            edgeMaterial.color = new THREE.Color(districtData.color);
            edgeMaterial.opacity = districtData.id === 'central-core' ? 0.5 : 0.3;
            const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
            platform.add(edges);
            
            // Inner glow ring - smaller for grid alignment
            const ringGeometry = new THREE.RingGeometry(hexSize * 0.65, hexSize * 0.75, 6);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: districtData.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.rotation.z = Math.PI / 6;
            ring.position.y = 4.1;
            districtGroup.add(ring);
            
            // Buildings (abstract representations) - scaled down for grid
            const buildingScale = scale * 0.8;
            districtData.nodes.forEach((nodeData, index) => {
                const building = createBuilding(nodeData, districtData.color);
                building.position.set(
                    nodeData.relPos.x * buildingScale, 
                    0, 
                    nodeData.relPos.z * buildingScale
                );
                building.scale.setScalar(0.9); // Slightly smaller buildings
                districtGroup.add(building);
                
                // Also create node for network view
                const node = createNode(
                    nodeData, 
                    districtData.position.x + nodeData.relPos.x * buildingScale,
                    districtData.position.z + nodeData.relPos.z * buildingScale,
                    districtData.color
                );
                node.visible = false;
                nodesGroup.add(node);
            });
            
            // Add subtle platform glow
            if (districtData.id === 'central-core') {
                const glowGeometry = new THREE.CircleGeometry(hexSize * 1.2, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: districtData.color,
                    transparent: true,
                    opacity: 0.05
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.rotation.x = -Math.PI / 2;
                glow.position.y = 0.2;
                districtGroup.add(glow);
            }
            
            return districtGroup;
        }
        
        function createBuilding(nodeData, color) {
            const buildingGroup = new THREE.Group();
            buildingGroup.userData = nodeData;
            
            // Varied building heights and shapes
            const baseSize = 6 + Math.random() * 4;
            const height = 10 + Math.random() * 15;
            const levels = Math.floor(height / 5);
            
            // Main structure with subtle variation
            const geometryType = Math.random();
            let geometry;
            
            if (geometryType < 0.4) {
                // Rectangular buildings
                geometry = new THREE.BoxGeometry(baseSize, height, baseSize);
            } else if (geometryType < 0.7) {
                // Cylindrical buildings
                geometry = new THREE.CylinderGeometry(baseSize * 0.5, baseSize * 0.6, height, 8);
            } else {
                // Hexagonal buildings
                geometry = new THREE.CylinderGeometry(baseSize * 0.5, baseSize * 0.5, height, 6);
            }
            
            const material = materials.building.clone();
            material.emissive = new THREE.Color(color);
            material.emissiveIntensity = 0.05;
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = height / 2 + 3;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            buildingGroup.add(mesh);
            
            // Window lights effect
            for (let i = 0; i < levels; i++) {
                const windowGeometry = new THREE.PlaneGeometry(baseSize * 0.8, 0.8);
                const windowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3 + Math.random() * 0.3
                });
                
                // Front and back windows
                for (let side = 0; side < 2; side++) {
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    window.position.y = 5 + i * 5;
                    window.position.z = side === 0 ? baseSize * 0.51 : -baseSize * 0.51;
                    if (side === 1) window.rotation.y = Math.PI;
                    buildingGroup.add(window);
                }
            }
            
            // Top beacon light
            const beaconGeometry = new THREE.BoxGeometry(baseSize * 0.8, 1, baseSize * 0.8);
            const beaconMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6
            });
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            beacon.position.y = height + 3.5;
            buildingGroup.add(beacon);
            
            // Activity indicator
            const activityGeometry = new THREE.SphereGeometry(1, 8, 6);
            const activityMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const activity = new THREE.Mesh(activityGeometry, activityMaterial);
            activity.position.y = height + 5;
            buildingGroup.add(activity);
            
            buildingGroup.userData.pulse = Math.random() * Math.PI * 2;
            buildingGroup.userData.beacon = beacon;
            buildingGroup.userData.activity = activity;
            
            return buildingGroup;
        }
        
        function createNode(nodeData, x, z, color) {
            const nodeGroup = new THREE.Group();
            nodeGroup.position.set(x, 1, z);
            nodeGroup.userData = nodeData;
            
            // Node base circle
            const geometry = new THREE.CircleGeometry(5, 32);
            const material = materials.node.clone();
            material.color = new THREE.Color(color);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            nodeGroup.add(mesh);
            
            // Node ring
            const ringGeometry = new THREE.RingGeometry(4, 5, 32);
            const ring = new THREE.Mesh(ringGeometry, material);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            nodeGroup.add(ring);
            
            // Node glow (for network view)
            const glowGeometry = new THREE.CircleGeometry(7, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.1
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.rotation.x = -Math.PI / 2;
            glow.position.y = -0.1;
            nodeGroup.add(glow);
            
            // Create label
            const label = document.createElement('div');
            label.className = 'node-label';
            label.textContent = nodeData.name;
            label.dataset.nodeId = nodeData.id;
            document.getElementById('ui-layer').appendChild(label);
            
            return nodeGroup;
        }
        
        // Particle system
        class DataParticle {
            constructor(from, to, color) {
                this.from = from;
                this.to = to;
                this.progress = 0;
                this.speed = 0.3 + Math.random() * 0.4;
                
                const geometry = new THREE.SphereGeometry(0.5, 8, 6);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.trail = [];
                this.maxTrailLength = 10;
                
                this.updatePosition();
                scene.add(this.mesh);
            }
            
            update(deltaTime) {
                this.progress += this.speed * deltaTime;
                
                if (this.progress >= 1) {
                    this.destroy();
                    return false;
                }
                
                this.updatePosition();
                return true;
            }
            
            updatePosition() {
                const t = this.progress;
                
                // Bezier curve for smoother movement
                const midPoint = {
                    x: (this.from.x + this.to.x) / 2,
                    y: 15 + Math.random() * 10,
                    z: (this.from.z + this.to.z) / 2
                };
                
                const p1 = 1 - t;
                const p2 = t;
                
                this.mesh.position.x = p1 * p1 * this.from.x + 2 * p1 * p2 * midPoint.x + p2 * p2 * this.to.x;
                this.mesh.position.y = p1 * p1 * 2 + 2 * p1 * p2 * midPoint.y + p2 * p2 * 2;
                this.mesh.position.z = p1 * p1 * this.from.z + 2 * p1 * p2 * midPoint.z + p2 * p2 * this.to.z;
                
                // Fade based on view mode
                const baseOpacity = state.viewMode === 'city' ? 0.6 : 0.8;
                this.mesh.material.opacity = baseOpacity * (1 - t * 0.5);
            }
            
            destroy() {
                scene.remove(this.mesh);
            }
        }
        
        // Enhanced lighting setup
        const ambientLight = new THREE.AmbientLight(0x404050, 0.4);
        scene.add(ambientLight);
        
        // Main directional light with shadows
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(80, 120, 60);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -150;
        directionalLight.shadow.camera.right = 150;
        directionalLight.shadow.camera.top = 150;
        directionalLight.shadow.camera.bottom = -150;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.bias = -0.001;
        scene.add(directionalLight);
        
        // Accent light from opposite direction
        const accentLight = new THREE.DirectionalLight(0x8b5cf6, 0.2);
        accentLight.position.set(-50, 80, -40);
        scene.add(accentLight);
        
        // Central point light for glow effect
        const centerLight = new THREE.PointLight(0x8b5cf6, 0.5, 100);
        centerLight.position.set(0, 30, 0);
        scene.add(centerLight);
        
        // Hemisphere light for ambient variation
        const hemiLight = new THREE.HemisphereLight(0x0a0a1a, 0x1a1a2e, 0.3);
        scene.add(hemiLight);
        
        // Camera controls
        function updateCamera() {
            if (!camera || !state.camera) return;
            
            const distance = state.camera.distance || 200;
            const angle = state.camera.angle || 0;
            const elevation = state.camera.elevation || Math.PI * 0.3;
            
            camera.position.x = Math.sin(angle) * Math.cos(elevation) * distance;
            camera.position.y = Math.sin(elevation) * distance;
            camera.position.z = Math.cos(angle) * Math.cos(elevation) * distance;
            camera.lookAt(0, 0, 0);
        }
        
        // Mouse controls
        let mouseX = 0, mouseY = 0;
        let startX = 0, startY = 0;
        
        renderer.domElement.addEventListener('mousedown', (e) => {
            state.mouse.down = true;
            startX = e.clientX;
            startY = e.clientY;
            document.body.classList.add('grabbing');
        });
        
        window.addEventListener('mousemove', (e) => {
            if (state.mouse.down) {
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                state.camera.angle -= deltaX * 0.01;
                state.camera.elevation = Math.max(0.1, Math.min(Math.PI / 3, 
                    state.camera.elevation - deltaY * 0.005));
                
                startX = e.clientX;
                startY = e.clientY;
                updateCamera();
            }
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        window.addEventListener('mouseup', () => {
            state.mouse.down = false;
            document.body.classList.remove('grabbing');
        });
        
        // Zoom control
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 1.1 : 0.9;
            state.camera.targetDistance *= delta;
            state.camera.targetDistance = Math.max(50, Math.min(300, state.camera.targetDistance));
        });
        
        // View mode management
        function updateViewMode() {
            const distance = state.camera.distance;
            
            if (distance > 150) {
                setViewMode('city');
            } else if (distance < 100) {
                setViewMode('network');
            } else {
                setViewMode('transition');
            }
        }
        
        function setViewMode(mode) {
            if (state.viewMode === mode) return;
            
            state.viewMode = mode;
            
            // Update UI
            const viewModeText = {
                'city': 'CITY VIEW • SCROLL TO ZOOM',
                'transition': 'TRANSITIONING...',
                'network': 'NETWORK VIEW • CLICK FOR DETAILS'
            };
            
            document.getElementById('view-mode').textContent = viewModeText[mode];
            
            // Update visibility and opacity
            if (mode === 'city') {
                // Show districts, hide nodes
                districtsGroup.visible = true;
                nodesGroup.visible = false;
                connectionsGroup.visible = false;
                scene.fog.near = 150;
                scene.fog.far = 400;
                
                // Update UI
                document.getElementById('nav').classList.remove('minimal');
                document.getElementById('controls').classList.remove('visible');
                document.getElementById('hud').classList.add('visible');
                window.updateCityHUD();
                
            } else if (mode === 'network') {
                // Hide districts, show nodes
                districtsGroup.visible = false;
                nodesGroup.visible = true;
                connectionsGroup.visible = true;
                scene.fog.near = 50;
                scene.fog.far = 200;
                
                // Update UI
                document.getElementById('nav').classList.add('minimal');
                document.getElementById('controls').classList.add('visible');
                window.updateNetworkHUD();
                
            } else {
                // Transition state - show both with transparency
                districtsGroup.visible = true;
                nodesGroup.visible = true;
                connectionsGroup.visible = true;
                
                const t = Math.max(0, Math.min(1, (state.camera.distance - 100) / 50));
                
                districtsGroup.traverse(child => {
                    if (child && child.isMesh && child.material && child.material.transparent !== undefined) {
                        child.material.opacity = Math.max(0.1, 0.8 * t);
                    }
                });
                
                nodesGroup.traverse(child => {
                    if (child && child.isMesh && child.material && child.material.transparent !== undefined) {
                        child.material.opacity = Math.max(0.1, 0.8 * (1 - t));
                    }
                });
            }
        }
        
        // HUD updates
        function updateCityHUD() {
            const hudContent = document.getElementById('hud-content');
            if (hudContent) {
                hudContent.innerHTML = `
                    <div class="metric">
                        <span class="metric-label">Active Districts</span>
                        <span class="metric-value">${cityData.districts.length}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Total Processes</span>
                        <span class="metric-value">${cityData.districts.reduce((sum, d) => sum + d.nodes.length, 0)}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Data Flow Rate</span>
                        <span class="metric-value">${Math.floor(2000 + Math.random() * 1000)}/s</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">System Health</span>
                        <span class="metric-value" style="color: #00ff88">98%</span>
                    </div>
                `;
            }
        }
        
        function updateNetworkHUD() {
            const hudContent = document.getElementById('hud-content');
            if (hudContent) {
                hudContent.innerHTML = `
                    <div class="metric">
                        <span class="metric-label">Active Nodes</span>
                        <span class="metric-value">${nodesGroup.children.length}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Connections</span>
                        <span class="metric-value">${connectionsGroup.children.length}</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Throughput</span>
                        <span class="metric-value">${Math.floor(30 + Math.random() * 20)}k msg/s</span>
                    </div>
                    <div class="metric">
                        <span class="metric-label">Latency</span>
                        <span class="metric-value">${Math.floor(10 + Math.random() * 5)}ms</span>
                    </div>
                `;
            }
        }
        
        // Spawn particles
        function spawnParticle() {
            if (!state.showFlow || particles.length > 30) return;
            
            const districts = cityData.districts;
            if (districts.length < 2) return;
            
            const fromIndex = Math.floor(Math.random() * districts.length);
            let toIndex = Math.floor(Math.random() * districts.length);
            
            // Ensure different districts
            while (toIndex === fromIndex) {
                toIndex = Math.floor(Math.random() * districts.length);
            }
            
            const fromDistrict = districts[fromIndex];
            const toDistrict = districts[toIndex];
            
            particles.push(new DataParticle(
                fromDistrict.position,
                toDistrict.position,
                fromDistrict.color
            ));
        }
        
        // Raycaster for interactions
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        renderer.domElement.addEventListener('click', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            if (state.viewMode === 'city') {
                const visibleDistricts = districtsGroup.children.filter(child => child.visible);
                const intersects = raycaster.intersectObjects(visibleDistricts, true);
                if (intersects.length > 0) {
                    let targetObject = intersects[0].object;
                    // Find the parent group with userData
                    while (targetObject && !targetObject.userData.id && targetObject.parent) {
                        targetObject = targetObject.parent;
                    }
                    if (targetObject && targetObject.userData && targetObject.userData.id) {
                        selectDistrict(targetObject.userData);
                    }
                }
            } else if (state.viewMode === 'network') {
                const visibleNodes = nodesGroup.children.filter(child => child.visible);
                const intersects = raycaster.intersectObjects(visibleNodes, true);
                if (intersects.length > 0) {
                    let targetObject = intersects[0].object;
                    // Find the parent group with userData
                    while (targetObject && !targetObject.userData.id && targetObject.parent && targetObject.parent !== nodesGroup) {
                        targetObject = targetObject.parent;
                    }
                    if (targetObject && targetObject.userData && targetObject.userData.id) {
                        selectNode(targetObject.userData);
                    }
                }
            }
        });
        
        // Selection handlers
        function selectDistrict(districtData) {
            state.selectedDistrict = districtData;
            
            // Update breadcrumb
            const breadcrumbSep = document.getElementById('breadcrumb-sep');
            const breadcrumbDistrict = document.getElementById('breadcrumb-district');
            
            if (breadcrumbSep) breadcrumbSep.style.display = 'inline';
            if (breadcrumbDistrict) {
                breadcrumbDistrict.style.display = 'inline';
                breadcrumbDistrict.textContent = districtData.name;
            }
            
            // Zoom to district
            state.camera.targetDistance = 80;
            
            // Show district details
            showDistrictInspector(districtData);
        }
        
        function selectNode(nodeData) {
            state.selectedNode = nodeData;
            showNodeInspector(nodeData);
        }
        
        function showDistrictInspector(districtData) {
            const inspector = document.getElementById('inspector');
            const title = document.getElementById('inspector-title');
            const content = document.getElementById('inspector-content');
            
            title.textContent = districtData.name;
            content.innerHTML = `
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 12px; color: #8b8b8b;">DISTRICT OVERVIEW</div>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Nodes</span>
                    <span class="metric-value">${districtData.nodes.length}</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Status</span>
                    <span class="metric-value" style="color: #00ff88">Operational</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Load</span>
                    <span class="metric-value">${Math.floor(60 + Math.random() * 30)}%</span>
                </div>
                <div style="margin-top: 20px;">
                    <div style="font-size: 12px; color: #8b8b8b; margin-bottom: 12px;">NODES</div>
                    ${districtData.nodes.map((node, index) => `
                        <div style="padding: 8px; background: rgba(139, 92, 246, 0.1); 
                                    border-radius: 6px; margin-bottom: 8px; cursor: pointer;"
                             id="district-node-${index}"
                             onmouseover="this.style.backgroundColor='rgba(139, 92, 246, 0.2)'"
                             onmouseout="this.style.backgroundColor='rgba(139, 92, 246, 0.1)'">
                            <div style="font-size: 13px; font-weight: 500;">${node.name}</div>
                            <div style="font-size: 11px; color: #8b8b8b; margin-top: 4px;">
                                Processing: ${Math.floor(100 + Math.random() * 200)} req/s
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            // Add click handlers for nodes
            districtData.nodes.forEach((node, index) => {
                const element = document.getElementById(`district-node-${index}`);
                if (element) {
                    element.onclick = () => {
                        state.camera.targetDistance = 80;
                        window.selectNode(node);
                    };
                }
            });
            
            inspector.classList.add('visible');
        }
        
        function showNodeInspector(nodeData) {
            const inspector = document.getElementById('inspector');
            const title = document.getElementById('inspector-title');
            const content = document.getElementById('inspector-content');
            
            title.textContent = nodeData.name;
            content.innerHTML = `
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 12px; color: #8b8b8b;">NODE DETAILS</div>
                    <div style="font-size: 11px; color: #666; margin-top: 4px;">ID: ${nodeData.id}</div>
                </div>
                <div class="metric">
                    <span class="metric-label">Status</span>
                    <span class="metric-value" style="color: #00ff88">Active</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Throughput</span>
                    <span class="metric-value">${Math.floor(100 + Math.random() * 200)}/s</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Latency</span>
                    <span class="metric-value">${Math.floor(5 + Math.random() * 10)}ms</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Error Rate</span>
                    <span class="metric-value" style="color: #00ff88">0.02%</span>
                </div>
                <div style="margin-top: 20px;">
                    <div style="font-size: 12px; color: #8b8b8b; margin-bottom: 12px;">RECENT EVENTS</div>
                    <div style="font-size: 11px; line-height: 1.6;">
                        <div style="margin-bottom: 6px;">
                            <span style="color: #666;">12:34:56</span> - 
                            <span>Configuration updated</span>
                        </div>
                        <div style="margin-bottom: 6px;">
                            <span style="color: #666;">12:33:45</span> - 
                            <span>Batch processed (1,234 items)</span>
                        </div>
                        <div style="margin-bottom: 6px;">
                            <span style="color: #666;">12:32:10</span> - 
                            <span>Health check passed</span>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 20px;">
                    <button class="control-btn" style="width: 100%;" 
                            onclick="window.alert('Opening node dashboard...')">
                        View Full Dashboard →
                    </button>
                </div>
            `;
            
            inspector.classList.add('visible');
        }
        
        // Control functions
        window.toggleFlow = (event) => {
            state.showFlow = !state.showFlow;
            if (event && event.target) {
                event.target.classList.toggle('active');
            }
        };
        
        window.toggleHeatmap = (event) => {
            state.showHeatmap = !state.showHeatmap;
            if (event && event.target) {
                event.target.classList.toggle('active');
            }
            
            // Update material emissive intensity based on "heat"
            districtsGroup.traverse(child => {
                if (child && child.isMesh && child.material && child.material.emissive) {
                    child.material.emissiveIntensity = state.showHeatmap ? 0.2 : 0.05;
                }
            });
        };
        
        window.resetView = () => {
            state.camera.targetDistance = 140;
            state.camera.angle = 0;
            state.camera.elevation = Math.PI * 0.35;
            state.selectedDistrict = null;
            state.selectedNode = null;
            
            const breadcrumbSep = document.getElementById('breadcrumb-sep');
            const breadcrumbDistrict = document.getElementById('breadcrumb-district');
            
            if (breadcrumbSep) breadcrumbSep.style.display = 'none';
            if (breadcrumbDistrict) breadcrumbDistrict.style.display = 'none';
            
            window.closeInspector();
        };
        
        window.closeInspector = () => {
            document.getElementById('inspector').classList.remove('visible');
        };
        
        window.setViewLevel = (level) => {
            if (level === 'city') {
                window.resetView();
            }
        };
        
        // Animation loop
        const clock = new THREE.Clock();
        let frameCount = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // Smooth camera zoom
            state.camera.distance += (state.camera.targetDistance - state.camera.distance) * 0.1;
            updateCamera();
            
            // Update view mode based on zoom
            updateViewMode();
            
            // Update buildings/nodes with smoother animations
            districtsGroup.traverse(child => {
                if (child.userData && child.userData.pulse !== undefined && child.scale) {
                    // Smooth pulsing animation
                    const pulseScale = 1 + Math.sin(elapsedTime * 1.5 + child.userData.pulse) * 0.03;
                    child.scale.y = pulseScale;
                    
                    // Update beacon brightness
                    if (child.userData.beacon) {
                        child.userData.beacon.material.opacity = 0.4 + 
                            Math.sin(elapsedTime * 3 + child.userData.pulse) * 0.3;
                    }
                    
                    // Update activity indicator
                    if (child.userData.activity) {
                        const activityScale = 0.8 + Math.sin(elapsedTime * 4 + child.userData.pulse) * 0.4;
                        child.userData.activity.scale.setScalar(activityScale);
                        child.userData.activity.material.opacity = 0.6 + 
                            Math.sin(elapsedTime * 4 + child.userData.pulse) * 0.2;
                    }
                }
            });
            
            // Animate central glow
            const centralDistrict = districtsGroup.children.find(d => 
                d.userData && d.userData.id === 'central-core'
            );
            if (centralDistrict) {
                const glowIntensity = 0.1 + Math.sin(elapsedTime * 0.5) * 0.05;
                centralDistrict.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        child.material.emissiveIntensity = glowIntensity;
                    }
                });
            }
            
            // Animate pulse ring
            cityGroup.traverse(child => {
                if (child.userData && child.userData.isPulseRing) {
                    const pulseScale = 1 + Math.sin(elapsedTime * 1.5) * 0.08;
                    child.scale.setScalar(pulseScale);
                    child.material.opacity = 0.25 + Math.sin(elapsedTime * 1.5) * 0.1;
                }
            });
            
            // Animate nodes in network view
            if (state.viewMode === 'network') {
                nodesGroup.children.forEach((node, index) => {
                    if (node.children && node.children[2]) { // The glow mesh
                        const glowScale = 1 + Math.sin(elapsedTime * 2 + index * 0.5) * 0.1;
                        node.children[2].scale.setScalar(glowScale);
                        node.children[2].material.opacity = 0.1 + Math.sin(elapsedTime * 2 + index * 0.5) * 0.05;
                    }
                });
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (!particles[i].update(deltaTime)) {
                    particles.splice(i, 1);
                }
            }
            
            // Update ambient particles
            if (state.viewMode === 'city') {
                updateAmbientParticles();
            }
            
            // Spawn particles
            if (frameCount % 45 === 0) {
                spawnParticle();
            }
            
            // Ambient particles for atmosphere
            if (frameCount % 120 === 0 && state.viewMode === 'city') {
                createAmbientParticle();
            }
            
            // Update labels
            updateLabels();
            
            // Update HUD periodically
            if (frameCount % 30 === 0) {
                if (state.viewMode === 'city') {
                    window.updateCityHUD();
                } else if (state.viewMode === 'network') {
                    window.updateNetworkHUD();
                }
            }
            
            renderer.render(scene, camera);
            frameCount++;
        }
        
        // Update labels
        function updateLabels() {
            // District labels
            document.querySelectorAll('.district-label').forEach(label => {
                const districtId = label.dataset.districtId;
                const district = cityData.districts.find(d => d.id === districtId);
                
                if (district && state.viewMode === 'city') {
                    const vector = new THREE.Vector3(
                        district.position.x,
                        25, // Higher position for better visibility
                        district.position.z
                    );
                    vector.project(camera);
                    
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                    
                    label.style.left = x + 'px';
                    label.style.top = y + 'px';
                    
                    // Check if label is behind camera
                    if (vector.z > 1) {
                        label.classList.remove('visible');
                    } else {
                        label.classList.add('visible');
                    }
                } else {
                    label.classList.remove('visible');
                }
            });
            
            // Node labels
            document.querySelectorAll('.node-label').forEach(label => {
                if (state.viewMode === 'network' && state.camera.distance < 120) {
                    const nodeId = label.dataset.nodeId;
                    const node = nodesGroup.children.find(n => n.userData && n.userData.id === nodeId);
                    
                    if (node && node.visible) {
                        const vector = node.position.clone();
                        vector.project(camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                        
                        label.style.left = x + 'px';
                        label.style.top = y + 'px';
                        
                        // Check if label is behind camera
                        if (vector.z > 1) {
                            label.classList.remove('visible');
                        } else {
                            label.classList.add('visible');
                        }
                    } else {
                        label.classList.remove('visible');
                    }
                } else {
                    label.classList.remove('visible');
                }
            });
        }
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Create network connections
        function createConnections() {
            const connections = [
                ['event-bus', 'lead-capture'],
                ['event-bus', 'validation'],
                ['event-bus', 'etl-pipeline'],
                ['event-bus', 'orchestrator'],
                ['lead-capture', 'validation'],
                ['validation', 'scoring'],
                ['scoring', 'routing'],
                ['etl-pipeline', 'transform-1'],
                ['etl-pipeline', 'transform-2'],
                ['transform-1', 'data-lake'],
                ['transform-2', 'data-lake'],
                ['orchestrator', 'ml-model-1'],
                ['orchestrator', 'ml-model-2'],
                ['ml-model-1', 'decision-engine'],
                ['ml-model-2', 'decision-engine'],
                ['api-gateway', 'webhook-handler'],
                ['api-gateway', 'event-publisher']
            ];
            
            connections.forEach(([fromId, toId]) => {
                const fromNode = nodesGroup.children.find(n => n.userData && n.userData.id === fromId);
                const toNode = nodesGroup.children.find(n => n.userData && n.userData.id === toId);
                
                if (fromNode && toNode) {
                    const points = [
                        fromNode.position,
                        toNode.position
                    ];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, materials.connection);
                    line.visible = false; // Start invisible
                    connectionsGroup.add(line);
                }
            });
        }
        
        // Ambient particles for atmosphere
        const ambientParticles = [];
        
        function createAmbientParticle() {
            if (ambientParticles.length > 30) return;
            
            const geometry = new THREE.SphereGeometry(0.2, 6, 4);
            const material = new THREE.MeshBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.4
            });
            
            const particle = new THREE.Mesh(geometry, material);
            particle.position.set(
                (Math.random() - 0.5) * 200,
                Math.random() * 50 + 10,
                (Math.random() - 0.5) * 200
            );
            
            particle.userData.velocity = {
                x: (Math.random() - 0.5) * 0.1,
                y: Math.random() * 0.05,
                z: (Math.random() - 0.5) * 0.1
            };
            particle.userData.life = 0;
            
            scene.add(particle);
            ambientParticles.push(particle);
        }
        
        // Update ambient particles in animation loop
        function updateAmbientParticles() {
            for (let i = ambientParticles.length - 1; i >= 0; i--) {
                const particle = ambientParticles[i];
                particle.userData.life += 0.01;
                
                // Movement
                particle.position.x += particle.userData.velocity.x;
                particle.position.y += particle.userData.velocity.y;
                particle.position.z += particle.userData.velocity.z;
                
                // Fade out
                particle.material.opacity = 0.4 * (1 - particle.userData.life);
                
                // Remove when faded
                if (particle.userData.life > 1) {
                    scene.remove(particle);
                    ambientParticles.splice(i, 1);
                }
            }
        }
        
        // Make functions globally accessible
        window.selectDistrict = selectDistrict;
        window.selectNode = selectNode;
        window.showDistrictInspector = showDistrictInspector;
        window.showNodeInspector = showNodeInspector;
        window.updateCityHUD = updateCityHUD;
        window.updateNetworkHUD = updateNetworkHUD;
        
        // Initialize
        createCity();
        createConnections();
        updateCamera();
        
        setTimeout(() => {
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.style.display = 'none';
            }
            const hudElement = document.getElementById('hud');
            if (hudElement) {
                hudElement.classList.add('visible');
            }
            window.updateCityHUD();
        }, 1000);
        
        // Start animation
        animate();
    </script>
</body>
</html>